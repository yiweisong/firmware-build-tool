import jsonimport struct import yamlimport osimport argparsefrom typings import ConfigurationContext,YMLElementfrom typing import ListDA_NAME = 'slave_da_UART.bin'def convert(source, cls):    obj = None    if isinstance(source, str):        return source        if isinstance(source, int):        return source    if not isinstance(cls, YMLElement):        obj = cls()    else:        obj = cls    if isinstance(source, List):        for item in source:            s = convert(item, obj.item_type)            obj.append(s)    if isinstance(source, dict):        for key in source:            if hasattr(cls, key):                setattr(obj, key, convert(source[key], getattr(obj, key)))            else:                setattr(obj, key, source[key])    return objclass StartOptions:    root:str = ''    config:str = ''    export_name:str = ''# -n export name(default combined_yyyyMMdd_hhmmss.bin)# -b root of binary(default ./bin)# -c configuration file(default ./config.cfg)def receive_args()-> StartOptions :     """parse input arguments    """    parser = argparse.ArgumentParser(        description='Aceinna python driver input args command:', allow_abbrev=False)    parser.add_argument("-n", dest="export_name", help="Export name", default='combined.bin')    parser.add_argument("-b", dest='root', help="Binary Files Container", default='./bin')    parser.add_argument("-c", dest="config", help="Config file", default='config.cfg')    startup_args = parser.parse_args()    startup_options = StartOptions()    startup_options.root = startup_args.root    startup_options.config = startup_args.config    startup_options.export_name = startup_args.export_name    return startup_optionsclass BuildProcess:    context: ConfigurationContext    json_content_length: bytes    json_content: bytes    configuration_content: List[bytes]    def __init__(self, options:StartOptions ) -> None:        self.root = options.root        self.config = options.config        self.export_name = options.export_name    def load_config(self):        print('Loading config...')        config = yaml.safe_load(open(self.config, 'r'))        self.context = convert(config, ConfigurationContext)        print('Loaded!')    def build_binary(self):        '''combine DA and configuration        '''        print('Building...')        self.configuration_content = []        configuration_json = {}        DA_content = open(os.path.join(self.root, DA_NAME),'rb').read()        self.configuration_content.append(DA_content)        configuration_json['DA'] = {'size': len(DA_content)}        for item in self.context.main_region.rom_list:            #TODO: check if binary file exists            file_path = os.path.join(self.root,item.rom.file)            if not os.path.exists(file_path):                continue            binary_content = open(file_path, 'rb').read()            self.configuration_content.append(binary_content)            configuration_json[item.rom.name] = {                'size': len(binary_content),                'beginAddress': item.rom.begin_address            }            if item.rom.bootloader:                configuration_json[item.rom.name]['isBootloader'] = True                self.json_content = bytes(json.dumps(configuration_json),'utf8')        self.json_content_length = struct.pack('<H', len(self.json_content))        print('Builded!')    def export_file(self):        print('Exporting...')        export_path = os.path.join('./export',self.export_name)        export_dir =  os.path.dirname(export_path)        if not os.path.isdir(export_dir):            os.makedirs(export_dir)                with open(export_path, 'wb') as write_steam:            write_steam.write(self.json_content_length)            write_steam.write(self.json_content)            for content in self.configuration_content:                write_steam.write(content)        print('Exported!')    def work(self):        self.load_config()        self.build_binary()        self.export_file()def main():    init_args = receive_args()    process = BuildProcess(init_args)    process.work()if __name__ == '__main__':    main()